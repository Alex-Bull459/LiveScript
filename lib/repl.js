// Generated by LiveScript 1.5.0
var LiveScript, path, fs, util, prelude, each, lines, unlines, take, keys, filter, dasherize, map, fileExists, dasherizeVars, startsWith;
LiveScript = require('..');
path = require('path');
fs = require('fs');
util = require('util');
prelude = require('prelude-ls'), each = prelude.each, lines = prelude.lines, unlines = prelude.unlines, take = prelude.take, keys = prelude.keys, filter = prelude.filter, dasherize = prelude.dasherize, map = prelude.map;
fileExists = function(path){
  try {
    fs.statSync(path);
    return true;
  } catch (e$) {}
};
dasherizeVars = function(str){
  if (/^[a-z]/.exec(str)) {
    return dasherize(str);
  } else {
    return str;
  }
};
startsWith = function(str){
  var this$ = this;
  return function(it){
    return it.indexOf(str) === 0;
  };
};
function repl(o, stdin, stdout){
  var say, warn, die, p, pp, ppp, MAXHISTORYSIZE, historyFile, code, cont, rl, reset, _ttyWrite, prompt, that, vm, replCtx, server, ref$;
  stdin == null && (stdin = process.stdin);
  stdout == null && (stdout = process.stdout);
  say = function(){
    return stdout.write(util.format.apply(null, arguments) + "\n");
  };
  warn = console.error;
  die = function(message){
    console.error(message);
    process.exit(1);
  };
  p = function(){
    var args, res$, i$, to$;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    each(console.dir, args);
  };
  pp = function(x, showHidden, depth){
    say(util.inspect(x, showHidden, depth, !process.env.NODE_DISABLE_COLORS));
  };
  ppp = function(it){
    pp(it, true, null);
  };
  MAXHISTORYSIZE = 500;
  historyFile = path.join(process.env.HOME, '/.lsc_history');
  code = repl.infunc ? '  ' : '';
  cont = 0;
  rl = require('readline').createInterface(stdin, stdout);
  reset = function(){
    rl.line = code = '';
    rl.prompt();
    repl.inheredoc = false;
  };
  (_ttyWrite = rl._ttyWrite, rl)._ttyWrite = function(char){
    if (char === '\n' || char === '>') {
      cont += 1;
    } else {
      cont = 0;
    }
    return _ttyWrite.apply(this, arguments);
  };
  prompt = 'ls';
  if (that = repeatString$('b', !!o.bare) + repeatString$('c', !!o.compile)) {
    prompt += " -" + that;
  }
  try {
    rl.history = lines(fs.readFileSync(historyFile, 'utf-8').trim());
  } catch (e$) {}
  if (LiveScript != null) {
    LiveScript.history = rl.history;
  }
  if (!o.compile) {
    module.paths = module.constructor._nodeModulePaths(module.filename = process.cwd() + '/repl');
    vm = require('vm');
    if (o.prelude) {
      import$(global, prelude);
    }
    replCtx = {};
    import$(replCtx, global);
    replCtx.module = module;
    replCtx.exports = exports;
    replCtx.require = require;
    replCtx.LiveScript = LiveScript;
    replCtx.path = path;
    replCtx.fs = fs;
    replCtx.util = util;
    replCtx.say = say;
    replCtx.warn = warn;
    replCtx.die = die;
    replCtx.p = p;
    replCtx.pp = pp;
    replCtx.ppp = ppp;
    server = (ref$ = clone$(require('repl').REPLServer.prototype), ref$.context = replCtx, ref$.commands = [], ref$.useGlobal = true, ref$.useColors = process.env.NODE_DISABLE_COLORS, ref$.eval = function(code, ctx, arg$, cb){
      var res, e;
      try {
        res = vm.runInNewContext(code, ctx, 'repl');
      } catch (e$) {
        e = e$;
      }
      cb(e, res);
    }, ref$);
    rl.completer = function(line, cb){
      var contextVars, matches;
      contextVars = map(dasherizeVars, keys(server.context));
      matches = filter(startsWith(line), contextVars);
      return cb(null, [matches.length ? matches : contextVars, line]);
    };
  }
  rl.on('SIGCONT', rl.prompt);
  rl.on('SIGINT', function(){
    if (this.line || code) {
      say('');
      reset();
    } else {
      this.close();
    }
  });
  rl.on('line', function(it){
    var isheredoc, ops, x, e;
    if (it.match(/^$/)) {
      repl.infunc = false;
    }
    if (it.match(/(\=|\~>|->|do|import|switch)\s*$/) || (it.match(/^!?(function|class|if|unless) /) && !it.match(/ then /))) {
      repl.infunc = true;
    }
    if (((0 < cont && cont < 3) || repl.infunc) && !repl.inheredoc) {
      code += it + '\n';
      this.output.write(repeatString$('.', prompt.length) + '. ');
      return;
    } else {
      isheredoc = it.match(/(\'\'\'|\"\"\")/g);
      if (isheredoc && isheredoc.length % 2 === 1) {
        repl.inheredoc = !repl.inheredoc;
      }
      if (repl.inheredoc) {
        code += it + '\n';
        rl.output.write(repeatString$('.', prompt.length) + '" ');
        return;
      }
    }
    repl.inheredoc = false;
    if (!(code += it)) {
      return reset();
    }
    try {
      if (o.compile) {
        say(LiveScript.compile(code, {
          bare: o.bare
        }));
      } else {
        ops = {
          'eval': 'eval',
          bare: true,
          saveScope: LiveScript
        };
        if (code.match(/^\s*!?function/)) {
          ops = {
            bare: true
          };
        }
        x = vm.runInNewContext(LiveScript.compile(code, ops), replCtx, 'repl');
        if (x != null) {
          replCtx._ = x;
        }
        pp(x);
        if (typeof x === 'function') {
          say(x);
        }
      }
    } catch (e$) {
      e = e$;
      say(e);
    }
    reset();
  });
  if (stdin === process.stdin) {
    rl.on('close', function(){
      say('');
      return process.exit();
    });
    process.on('uncaughtException', function(it){
      say("\n" + ((it != null ? it.stack : void 8) || it));
    });
    process.on('exit', function(){
      if (code && rl.output.isTTY) {
        rl._ttyWrite('\r');
      }
      if (fileExists(historyFile)) {
        fs.writeFileSync(historyFile, compose$(take(MAXHISTORYSIZE), unlines)(rl.history));
      }
    });
  }
  rl.setPrompt(prompt + "> ");
  rl.prompt();
}
module.exports = repl;
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
function compose$() {
  var functions = arguments;
  return function() {
    var i, result;
    result = functions[0].apply(this, arguments);
    for (i = 1; i < functions.length; ++i) {
      result = functions[i](result);
    }
    return result;
  };
}