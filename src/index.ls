require! {
  './lexer'
  './parser': {parser}
  './ast'
  'source-map': {SourceNode}
}

# Override Jison's default lexer, so that it can accept
# the generic stream of tokens our lexer produces.
parser <<<
  yy: ast
  lexer:
    lex: ->
      [tag, @yytext, first_line, first_column] = @tokens[++@pos] or [''];
      [_, _, last_line, last_column] = @tokens[@pos+1] or [''];
      @yylineno = first_line
      @yylloc =
        first_line: first_line
        first_column: first_column
        last_line: last_line
        last_column: last_column
      tag
    set-input: -> @pos = -1; @tokens = it
    upcoming-input: -> ''

exports <<<
  VERSION: '1.3.2'

  # Compiles a string of LiveScript code to JavaScript.
  compile: (code, options = {}) ->
    options.header ?= true
    try
      if options.json
        result = do Function exports.compile code, {+bare, +run, +print}
        JSON.stringify(result, null, 2) + '\n'
      else
        ast = parser.parse lexer.lex code
        ast.make-return! if options.run and options.print
        output = ast.compile-root options
        output = new SourceNode(null, null, null, ["// Generated by LiveScript #{exports.VERSION}\n", output]) if options.header
        if options.map
          unless options.filename
            options.filename = "unnamed-" + (Math.floor(Math.random()*4294967296)).toString(16) + ".ls"

          output.setFile(options.filename)
          result = output.toStringWithSourceMap()
          unless options.dontEmbedSource
            result.map.setSourceContent(options.filename, code)
          unless options.dontEmbedMap
            result.code + '\n//# sourceMappingURL=data:application/json;base64,' + new Buffer(result.map.toString()).toString('base64') + '\n'
          else
            result
        else
          output.toString()
    catch
      e.message += "\nat #that" if options.filename
      throw e

  # Parses a string or tokens of LiveScript code,
  # returning the [AST](http://en.wikipedia.org/wiki/Abstract_syntax_tree).
  ast: -> parser.parse if typeof it is 'string' then lexer.lex it else it

  # Tokenizes a string of LiveScript code, returning the array of tokens.
  tokens: lexer.lex

  # Same as `tokens`, except that this skips rewriting.
  lex: -> lexer.lex it, {+raw}

  # Runs LiveScript code directly.
  run: (code, options) -> do Function exports.compile code, {...options, +bare}

exports.tokens.rewrite = lexer.rewrite

# Export AST constructors.
exports.ast <<<< parser.yy

if require.extensions
  (require './node') exports
else
  # Attach `require` for debugging.
  exports <<< {require}
